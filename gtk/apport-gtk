#!/usr/bin/python

'''GTK Apport user interface.'''

# Copyright (C) 2007 - 2009 Canonical Ltd.
# Author: Martin Pitt <martin.pitt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for
# the full text of the license.

import os.path, sys, subprocess, os, re

from gi.repository import GObject
from gi.repository import GLib
try:
    from gi.repository import Gtk
except RuntimeError as e:
    # probably session just closing down?
    sys.stderr.write('Cannot start: %s\n' % str(e))
    sys.exit(1)

import apport
from apport import unicode_gettext as _
import apport.ui
from gi.repository import Gdk

class GTKUserInterface(apport.ui.UserInterface):
    '''GTK UserInterface.'''

    def w(self, widget):
        '''Shortcut for getting a widget.'''

        return self.widgets.get_object(widget)

    def __init__(self):
        apport.ui.UserInterface.__init__(self)

        # load UI
        Gtk.Window.set_default_icon_name('apport')
        self.widgets = Gtk.Builder()
        self.widgets.set_translation_domain(self.gettext_domain)
        self.widgets.add_from_file(os.path.join(os.path.dirname(sys.argv[0]),
            'apport-gtk.ui'))

        # connect signal handlers
        assert self.widgets.connect_signals(self) is None

        # initialize tree model and view
        self.tree_model = self.w('details_treestore')

        column = Gtk.TreeViewColumn('Report', Gtk.CellRendererText(), text=0)
        self.w('details_treeview').append_column(column)
        self.spinner = self.add_spinner_over_treeview(self.w('details_treeview'))

        self.md = None

    #
    # ui_* implementation of abstract UserInterface classes
    #

    def add_spinner_over_treeview(self, treeview):
        '''Reparents a treeview in a GtkOverlay, then layers a GtkSpinner
        centered on top.'''
        # TODO handle the expose event of the spinner so that we can draw on
        # the treeview's viewport's window instead.
        parent = treeview.get_parent()
        parent.remove(treeview)
        overlay = Gtk.Overlay()
        parent.add_with_viewport(overlay)
        overlay.add(treeview)
        spinner = Gtk.Spinner()
        spinner.set_size_request(42, 42)
        align = Gtk.Alignment()
        align.set_valign(Gtk.Align.CENTER)
        align.set_halign(Gtk.Align.CENTER)
        align.add(spinner)
        overlay.add_overlay(align)
        overlay.show()
        align.show()
        spinner.hide()
        return spinner

    def ui_update_view(self, shown_keys=None):
        if shown_keys:
            keys = set(self.report.keys()) & set(shown_keys)
        else:
            keys = self.report.keys()
        # show the most interesting items on top
        keys = sorted(keys)
        for k in ('Traceback', 'StackTrace', 'Title', 'ProblemType', 'Package', 'ExecutablePath'):
            if k in keys:
                keys.remove(k)
                keys.insert(0, k)

        self.tree_model.clear()
        for key in keys:
            keyiter = self.tree_model.insert_before(None, None)
            self.tree_model.set_value(keyiter, 0, key)

            valiter = self.tree_model.insert_before(keyiter, None)
            if not hasattr(self.report[key], 'gzipvalue') and \
                hasattr(self.report[key], 'isspace') and \
                not self.report._is_binary(self.report[key]):
                self.tree_model.set_value(valiter, 0, self.report[key])
                # expand the row if the value has less than 5 lines
                if len(filter(lambda c: c == '\n', self.report[key])) < 4:
                    self.w('details_treeview').expand_row(
                        self.tree_model.get_path(keyiter), False)
            else:
                self.tree_model.set_value(valiter, 0, _('(binary data)'))

    def get_system_application_title(self):
        '''Get dialog title for a non-.desktop application.

        If the system application was started from the console, assume a
        developer who would appreciate the application name having a more
        prominent placement. Otherwise, provide a simple explanation for
        more novice users.
        '''
        from_console = 'TERM=' in self.report.get('ProcEnviron', '')

        if from_console:
            if 'ExecutablePath' in self.report:
                t = (_('Sorry, the application %s has closed unexpectedly.')
                     % os.path.basename(self.report['ExecutablePath']))
            else:
                t = (_('Sorry, %s has closed unexpectedly.') %
                     self.cur_package)

        else:
            if 'DistroRelease' not in self.report:
                self.report.add_os_info()
            t = _('Sorry, %s has experienced an internal error.') % self.report['DistroRelease']
        return t

    def setup_bug_report(self):
        # This is a bug generated through `apport-bug $package`.
        self.w('title_label').set_label('<big><b>%s</b></big>' %
            _('Send problem report to the developers?'))
        self.w('title_label').show()
        self.w('subtitle_label').hide()
        self.w('closed_button').hide()
        self.w('ignore_future_problems').hide()
        self.w('show_details').clicked()
        self.w('show_details').hide()
        self.w('cancel_button').show()
        self.w('cancel_button').connect('clicked', Gtk.main_quit)
        self.w('continue_button').set_label(_('Send'))
        self.w('send_error_report').set_active(True)
        self.w('send_error_report').hide()

    def ui_present_report_details(self, allowed_to_report=True):
        icon = None
        self.collect_called = False
        report_type = self.report.get('ProblemType')
        self.w('details_scrolledwindow').hide()
        self.w('show_details').set_label(_('Show Details'))
        self.tree_model.clear()

        if allowed_to_report:
            self.w('send_error_report').set_active(True)
            self.w('send_error_report').show()
        else:
            self.w('send_error_report').set_active(False)
            self.w('send_error_report').hide()

        self.w('examine').set_visible(self.can_examine_locally())

        self.w('continue_button').set_label(_('Continue'))

        self.w('cancel_button').hide()
        if not self.report_file:
            self.setup_bug_report()
        elif report_type == 'KernelCrash' or report_type == 'KernelOops':
            self.w('ignore_future_problems').set_active(False)
            self.w('ignore_future_problems').hide()
            self.w('title_label').set_label('<big><b>%s</b></big>' %
                                            self.get_system_application_title())
            self.w('closed_button').hide()
            self.w('subtitle_label').hide()
            icon = 'distributor-logo'
        elif report_type == 'Package':
            package = self.report.get('Package')
            if package:
                self.w('subtitle_label').set_label(_('Package: %s') % package)
                self.w('subtitle_label').show()
            else:
                self.w('subtitle_label').hide()
            self.w('closed_button').hide()
            self.w('ignore_future_problems').hide()
            self.w('title_label').set_label(
                _('Sorry, a problem occurred while installing software.'))
        else:
            # Regular crash.
            desktop_file = self.get_desktop_entry()
            if desktop_file:
                icon = desktop_file.getIcon()
                n = desktop_file.getName().encode('UTF-8')
                n = GLib.markup_escape_text(n).decode('UTF-8')
                self.w('title_label').set_label('<big><b>%s</b></big>' %
                    _('The application %s has closed unexpectedly.') % n)
                self.w('subtitle_label').hide()
                self.w('closed_button').show()
                self.w('closed_button').set_label(_('Leave Closed'))
                self.w('continue_button').set_label(_('Relaunch'))
            else:
                icon = 'distributor-logo'
                title_text = self.get_system_application_title()
                self.w('title_label').set_label('<big><b>%s</b></big>' %
                                                title_text)
                self.w('subtitle_label').show()
                self.w('subtitle_label').set_label(
                    _('If you notice further problems, '
                      'try restarting the computer.'))
                self.w('closed_button').hide()
                self.w('continue_button').set_label(_('Continue'))
            if self.report.get('CrashCounter'):
                self.w('ignore_future_problems').show()
            else:
                self.w('ignore_future_problems').hide()

        if icon:
            from gi.repository import GdkPixbuf
            builtin = Gtk.IconLookupFlags.USE_BUILTIN
            app_icon = self.w('application_icon')
            theme = Gtk.IconTheme.get_default()
            try:
                pb = theme.load_icon(icon, 42, builtin)
                overlay = theme.load_icon('dialog-error', 16, builtin)
                overlay.composite(pb, 26, 26, 16, 16, 26, 26, 1, 1,
                                  GdkPixbuf.InterpType.BILINEAR, 255)
                app_icon.set_from_pixbuf(pb)
            except GLib.GError:
                self.w('application_icon').set_from_stock(
                    Gtk.STOCK_DIALOG_ERROR, Gtk.IconSize.DIALOG)
        else:
            self.w('application_icon').set_from_stock(Gtk.STOCK_DIALOG_ERROR,
                                                      Gtk.IconSize.DIALOG)

        d = self.w('dialog_crash_new')
        if 'DistroRelease' in self.report:
            d.set_title(self.report['DistroRelease'].split()[0])
        d.set_resizable(False)
        d.show()
        # don't steal focus when being called without arguments (i. e.
        # automatically launched)
        if len(sys.argv) == 1:
            d.set_focus_on_map(False)

        return_value = { 'report' : False, 'blacklist' : False,
                         'restart' : False, 'examine' : False }
        def dialog_crash_dismissed(widget):
            self.w('dialog_crash_new').hide()
            if widget is self.w('dialog_crash_new'):
                Gtk.main_quit()
                return
            elif widget is self.w('examine'):
                return_value['examine'] = True
                Gtk.main_quit()
                return

            if self.w('send_error_report').get_active():
                return_value['report'] = True
            if self.w('ignore_future_problems').get_active():
                return_value['blacklist'] = True
            if widget.get_label() == _('Relaunch'):
                return_value['restart'] = True
            Gtk.main_quit()

        self.w('dialog_crash_new').connect('destroy', dialog_crash_dismissed)
        self.w('continue_button').connect('clicked', dialog_crash_dismissed)
        self.w('closed_button').connect('clicked', dialog_crash_dismissed)
        self.w('examine').connect('clicked', dialog_crash_dismissed)
        Gtk.main()
        return return_value

    def _ui_message_dialog(self, title, text, _type,
            buttons=Gtk.ButtonsType.CLOSE):
        self.md = Gtk.MessageDialog(message_type=_type, buttons=buttons)
        if 'http://' in text or 'https://' in text:
            if type(text) != type(b''):
                text = text.encode('UTF-8')
            text = GLib.markup_escape_text(text)
            text = re.sub(r'(https?://[a-zA-Z0-9._-]+(?:[a-zA-Z0-9_#?%/-])*)',
                    r'<a href="\1">\1</a>', text)
            # turn URLs into links
            self.md.set_markup(text)
        else:
            # work around gnome #620579
            self.md.set_property('text', text)
        self.md.set_title(title)
        result = self.md.run()
        self.md.hide()
        while Gtk.events_pending():
            Gtk.main_iteration_do(False)
        self.md = None
        return result

    def ui_info_message(self, title, text):
        self._ui_message_dialog(title, text, Gtk.MessageType.INFO)

    def ui_error_message(self, title, text):
        self._ui_message_dialog(title, text, Gtk.MessageType.ERROR)

    def ui_shutdown(self):
        Gtk.main_quit()

    def ui_start_upload_progress(self):
        '''Open a window with an definite progress bar, telling the user to
        wait while debug information is being uploaded.'''

        self.w('progressbar_upload').set_fraction(0)
        self.w('window_report_upload').show()
        while Gtk.events_pending():
            Gtk.main_iteration_do(False)

    def ui_set_upload_progress(self, progress):
        '''Set the progress bar in the debug data upload progress
        window to the given ratio (between 0 and 1, or None for indefinite
        progress).

        This function is called every 100 ms.'''

        if progress:
            self.w('progressbar_upload').set_fraction(progress)
        else:
            self.w('progressbar_upload').set_pulse_step(0.1)
            self.w('progressbar_upload').pulse()
        while Gtk.events_pending():
            Gtk.main_iteration_do(False)

    def ui_stop_upload_progress(self):
        '''Close debug data upload progress window.'''

        self.w('window_report_upload').hide()
        while Gtk.events_pending():
            Gtk.main_iteration_do(False)

    def ui_start_info_collection_progress(self):
        # show a spinner if we already have the main window
        if self.w('dialog_crash_new').get_property('visible'):
            self.spinner.show()
            self.spinner.start()
        else:
            # show a progress dialog
            self.w('progressbar_information_collection').set_fraction(0)
            self.w('window_information_collection').show()

        while Gtk.events_pending():
            Gtk.main_iteration_do(False)

    def ui_pulse_info_collection_progress(self):
        if self.w('window_information_collection').get_property('visible'):
            self.w('progressbar_information_collection').pulse()

        # for a spinner we just need to handle events
        while Gtk.events_pending():
            Gtk.main_iteration_do(False)

    def ui_stop_info_collection_progress(self):
        if self.w('window_information_collection').get_property('visible'):
            self.w('window_information_collection').hide()
        else:
            self.spinner.hide()
            self.spinner.stop()

        while Gtk.events_pending():
            Gtk.main_iteration_do(False)

    def ui_question_yesno(self, text):
        '''Show a yes/no question.

        Return True if the user selected "Yes", False if selected "No" or
        "None" on cancel/dialog closing.
        '''
        result = self._ui_message_dialog('', text, Gtk.MessageType.QUESTION,
                Gtk.ButtonsType.YES_NO)
        if result == Gtk.ResponseType.YES:
            return True
        if result == Gtk.ResponseType.NO:
            return False
        return None

    def ui_question_choice(self, text, options, multiple):
        '''Show an question with predefined choices.

        options is a list of strings to present. If multiple is True, they
        should be check boxes, if multiple is False they should be radio
        buttons.

        Return list of selected option indexes, or None if the user cancelled.
        If multiple == False, the list will always have one element.
        '''
        d = self.w('dialog_choice')
        d.set_default_size(400, -1)
        self.w('label_choice_text').set_label(text)

        # remove previous choices
        for child in self.w('vbox_choices').get_children():
            child.destroy()

        b = None
        for option in options:
            if multiple:
                b = Gtk.CheckButton.new_with_label(option)
            else:
                # use previous radio button as group; work around GNOME#635253
                if b:
                    b = Gtk.RadioButton.new_with_label_from_widget(b, option)
                else:
                    b = Gtk.RadioButton.new_with_label([], option)
            self.w('vbox_choices').pack_start(b, True, True, 0)
        self.w('vbox_choices').show_all()

        result = d.run()
        d.hide()
        if result != Gtk.ResponseType.OK:
            return None

        index = 0
        result = []
        for c in self.w('vbox_choices').get_children():
            if c.get_active():
                result.append(index)
            index += 1
        return result

    def ui_question_file(self, text):
        '''Show a file selector dialog.

        Return path if the user selected a file, or None if cancelled.
        '''
        md = Gtk.FileChooserDialog(text,
                parent=self.w('window_information_collection'),
                buttons=(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK))
        result = md.run()
        md.hide()
        while Gtk.events_pending():
            Gtk.main_iteration_do(False)
        if result == Gtk.ResponseType.OK:
            return md.get_filenames()[0]
        else:
            return None

    def ui_run_terminal(self, command):
        terminals = ['x-terminal-emulator', 'gnome-terminal', 'terminator',
                'xfce4-terminal', 'xterm']

        program = None
        for t in terminals:
            program = GLib.find_program_in_path(t)
            if program:
                break

        if not command:
            # test mode
            return 'DISPLAY' in os.environ and program is not None

        subprocess.call([program, '-e', command], stdout=subprocess.PIPE)

    #
    # Event handlers
    #

    def on_show_details_clicked(self, widget):
        sw = self.w('details_scrolledwindow')
        if sw.get_property('visible'):
            self.w('dialog_crash_new').set_resizable(False)
            sw.hide()
            widget.set_label(_('Show Details'))
        else:
            self.w('dialog_crash_new').set_resizable(True)
            sw.show()
            widget.set_label(_('Hide Details'))
            if not self.collect_called:
                self.collect_called = True
                self.ui_update_view(['ExecutablePath'])
                GLib.idle_add(lambda: self.collect_info(on_finished=self.ui_update_view))
        return True

    def on_progress_window_close_event(self, widget, event=None):
        self.w('window_information_collection').hide()
        self.w('window_report_upload').hide()
        sys.exit(0)
        return True

if __name__ == '__main__':
    if not os.environ.get('DISPLAY'):
        apport.fatal('This program needs a running X session. Please see "man apport-cli" for a command line version of Apport.')
    app = GTKUserInterface()
    app.run_argv()
